<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kids Creative Studio (AI Math Solver)</title>
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Font Awesome for tool icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
        }
        #drawingCanvas {
            touch-action: none; /* Prevents default touch behavior like scrolling */
            border: 4px solid #3b82f6; /* Primary Blue border */
            border-radius: 1.5rem;
            background-color: #ffffff;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2); /* Deeper shadow */
            cursor: crosshair;
            max-width: 100%;
            height: auto;
        }
        .control-button {
            padding: 0.75rem 1.5rem;
            font-weight: 700;
            border-radius: 9999px;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            white-space: nowrap; /* Prevent button text wrapping */
        }
        .control-button:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }
        .tool-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: background-color 0.15s, transform 0.1s;
            border: 2px solid transparent;
            min-width: 60px; /* Uniform width for tools */
        }
        .tool-icon.selected {
            background-color: #e0f2fe; /* Light blue background for selection */
            border-color: #3b82f6;
            transform: scale(1.05);
        }
        .color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
            border: 3px solid transparent;
        }
        .color-swatch:hover {
            transform: scale(1.1);
        }
        .color-swatch.selected {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px white;
        }
        #solve-button {
            background-color: #10b981; /* Green */
            color: white;
            font-size: 1.125rem;
            box-shadow: 0 6px #059669; /* Darker green shadow */
        }
        #solve-button:active {
            box-shadow: 0 2px #059669;
            transform: translateY(4px);
        }
    </style>
</head>
<body class="p-4 sm:p-8 flex flex-col items-center min-h-screen">

    <header class="text-center mb-8">
        <h1 class="text-5xl font-extrabold text-pink-600 mb-2">Creative Studio</h1>
        <p class="text-xl text-gray-700">Draw, Color, and Solve Math Problems!</p>
    </header>

    <!-- Canvas Wrapper -->
    <div class="w-full max-w-4xl flex flex-col items-center">
        <!-- Size Controls -->
        <div class="flex flex-wrap justify-center gap-4 mb-4 text-gray-700 font-semibold w-full">
            <button onclick="changeCanvasSize(-1)" class="px-4 py-2 bg-yellow-400 text-gray-800 rounded-lg hover:bg-yellow-500 transition shadow-md">
                <i class="fas fa-search-minus mr-1"></i> Smaller
            </button>
            <span id="canvas-size-display" class="text-xl flex items-center bg-white px-4 rounded-lg shadow-inner border border-gray-200">
                Canvas Size: 800 x 800
            </span>
            <button onclick="changeCanvasSize(1)" class="px-4 py-2 bg-yellow-400 text-gray-800 rounded-lg hover:bg-yellow-500 transition shadow-md">
                Larger <i class="fas fa-search-plus ml-1"></i>
            </button>
        </div>
        <canvas id="drawingCanvas" width="800" height="800"></canvas>
        
        <!-- AI Math Solver Button -->
        <div class="mt-6 w-full max-w-lg">
             <button id="solve-button" onclick="solveHandwrittenMath()" class="w-full control-button disabled:opacity-50">
                <i class="fas fa-brain mr-2"></i> Solve Handwritten Math
            </button>
        </div>
    </div>

    <!-- Controls -->
    <div id="controls" class="mt-8 p-6 bg-white rounded-2xl shadow-2xl w-full max-w-2xl">
        
        <!-- Undo/Redo and Action Buttons (Including NEW Grid Button) -->
        <div class="flex flex-wrap justify-center gap-4 mb-6 pb-4 border-b border-gray-100">
            <button id="undo-button" onclick="undo()" class="control-button bg-gray-400 text-white hover:bg-gray-500 disabled:opacity-50" disabled>
                <i class="fas fa-undo mr-2"></i> Undo
            </button>
            <button id="redo-button" onclick="redo()" class="control-button bg-gray-400 text-white hover:bg-gray-500 disabled:opacity-50" disabled>
                <i class="fas fa-redo mr-2"></i> Redo
            </button>
            <button id="toggle-grid-button" onclick="toggleGrid()" class="control-button bg-purple-500 text-white hover:bg-purple-600">
                <i class="fas fa-th-large mr-2"></i> Show Grid
            </button>
            <button id="clear-button" onclick="clearCanvas()" class="control-button bg-red-500 text-white hover:bg-red-600">
                <i class="fas fa-trash mr-2"></i> Clear
            </button>
            <button id="save-button" onclick="saveDrawing()" class="control-button bg-blue-600 text-white hover:bg-blue-700">
                <i class="fas fa-download mr-2"></i> Save
            </button>
        </div>

        <!-- Tool Selection -->
        <div class="mb-6">
            <h3 class="font-bold text-center text-lg text-gray-800 mb-3">Drawing Tool</h3>
            <div id="tool-selector" class="flex justify-around items-end space-x-4">
                <!-- Pen Tool -->
                <div class="tool-icon selected" data-tool="pen" onclick="setTool('pen')">
                    <i class="fas fa-pen text-2xl text-gray-600 mb-1"></i>
                    <span class="text-xs font-medium text-gray-600">Pen</span>
                </div>
                <!-- Pencil Tool -->
                <div class="tool-icon" data-tool="pencil" onclick="setTool('pencil')">
                    <i class="fas fa-pencil-alt text-2xl text-gray-600 mb-1"></i>
                    <span class="text-xs font-medium text-gray-600">Pencil</span>
                </div>
                <!-- Brush Tool -->
                <div class="tool-icon" data-tool="brush" onclick="setTool('brush')">
                    <i class="fas fa-paint-brush text-2xl text-gray-600 mb-1"></i>
                    <span class="text-xs font-medium text-gray-600">Brush</span>
                </div>
                <!-- Eraser Tool -->
                <div class="tool-icon" data-tool="eraser" onclick="setTool('eraser')">
                    <i class="fas fa-eraser text-2xl text-gray-600 mb-1"></i>
                    <span class="text-xs font-medium text-gray-600">Eraser</span>
                </div>
            </div>
        </div>

        <!-- Color Palette and Size Control -->
        <div class="grid grid-cols-1 lg:grid-cols-5 gap-6 items-center pt-4 border-t border-gray-100">
            
            <div class="col-span-1 lg:col-span-3">
                <h3 class="font-bold text-center text-lg text-gray-800 mb-3">Color Palette</h3>
                <div id="color-palette" class="flex flex-wrap justify-center gap-2">
                    <!-- Predefined Colors -->
                    <div class="color-swatch selected" style="background-color: #3b82f6;" data-color="#3b82f6" onclick="selectColor('#3b82f6', this)"></div>
                    <div class="color-swatch" style="background-color: #ef4444;" data-color="#ef4444" onclick="selectColor('#ef4444', this)"></div>
                    <div class="color-swatch" style="background-color: #10b981;" data-color="#10b981" onclick="selectColor('#10b981', this)"></div>
                    <div class="color-swatch" style="background-color: #f59e0b;" data-color="#f59e0b" onclick="selectColor('#f59e0b', this)"></div>
                    <div class="color-swatch" style="background-color: #8b5cf6;" data-color="#8b5cf6" onclick="selectColor('#8b5cf6', this)"></div>
                    <div class="color-swatch" style="background-color: #000000;" data-color="#000000" onclick="selectColor('#000000', this)"></div>
                    <div class="color-swatch" style="background-color: #ffffff; border-color: #ccc;" data-color="#ffffff" onclick="selectColor('#ffffff', this)"></div>

                    <!-- Custom Color Picker -->
                    <div id="color-control" class="flex items-center ml-2">
                        <input type="color" id="color-picker" value="#3b82f6" onchange="updateStrokeColor(this.value)" class="w-10 h-10 rounded-full border-2 border-gray-300 cursor-pointer">
                    </div>
                </div>
            </div>

            <!-- Brush Size Slider -->
            <div class="col-span-1 lg:col-span-2 flex flex-col items-center">
                <label for="size-slider" class="font-bold text-lg text-gray-800 mb-2">
                    Size: <span id="size-value">2</span>px
                </label>
                <input type="range" id="size-slider" min="1" max="50" value="2" oninput="updateStrokeSize(this.value)" class="w-full h-3 bg-gray-200 rounded-lg appearance-none cursor-pointer">
            </div>
        </div>
    </div>
    
    <!-- Custom Modal for Notifications -->
    <div id="notification-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-xl p-6 shadow-2xl max-w-sm w-full text-center">
            <p id="modal-message" class="text-lg font-semibold text-gray-800 mb-4">Message</p>
            <button onclick="hideModal()" class="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition">OK</button>
        </div>
    </div>

<script>
    // ------------------------------------------------------------------
    // यहाँ (नीचे दी गई लाइन में) आपको अपनी Gemini API Key डालनी है।
    // कृपया "YOUR_API_KEY_HERE" को हटाकर अपनी असली Key पेस्ट करें।
    // ------------------------------------------------------------------
    const API_KEY = "AIzaSyAqzTp65Q8-zyOWDsDuzLUlWnzK2LUThgM"; 

    const CANVAS_BACKGROUND = '#ffffff'; 
    const DEFAULT_COLOR = '#3b82f6';
    const GRID_SIZE = 50; // Grid cell size in pixels

    const TOOL_SETTINGS = {
        'pen': { size: 3, lineCap: 'butt', lineJoin: 'bevel' },
        'pencil': { size: 1, lineCap: 'round', lineJoin: 'round' },
        'brush': { size: 18, lineCap: 'round', lineJoin: 'round' },
        'eraser': { size: 25, lineCap: 'round', lineJoin: 'round' }
    };
    
    // Updated Canvas Sizes - More options added
    const CANVAS_SIZES = [
        { size: 400, display: "Small" },
        { size: 600, display: "Medium" },
        { size: 800, display: "Large" },
        { size: 1000, display: "X-Large" }, 
        { size: 1200, display: "XX-Large" }, 
        { size: 1400, display: "Jumbo" } 
    ];

    // --- State Variables (Drawing) ---
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let currentTool = 'pen';
    let currentStrokeColor = DEFAULT_COLOR; 
    let currentStrokeSize = TOOL_SETTINGS['pen'].size;
    let currentCanvasSizeIndex = 2; // Start at Large (800x800)
    let isGridVisible = false; // State for grid visibility

    let history = [];
    let historyIndex = -1;
    const MAX_HISTORY_STEPS = 50;

    // --- DOM and Canvas Setup ---
    const canvas = document.getElementById('drawingCanvas');
    const ctx = canvas.getContext('2d');
    const modal = document.getElementById('notification-modal');
    const modalMessage = document.getElementById('modal-message');
    const sizeValueEl = document.getElementById('size-value');
    const sizeSliderEl = document.getElementById('size-slider');
    const colorPickerEl = document.getElementById('color-picker');
    const colorControlEl = document.getElementById('color-control');
    const undoButton = document.getElementById('undo-button');
    const redoButton = document.getElementById('redo-button');
    const solveButton = document.getElementById('solve-button');
    const toggleGridButton = document.getElementById('toggle-grid-button'); 
    const canvasSizeDisplayEl = document.getElementById('canvas-size-display');


    // ------------------------------------------------------------------
    // --- AI MATH SOLVER LOGIC (API Call) ---
    // ------------------------------------------------------------------

    // Utility function for exponential backoff retry logic
    async function fetchWithRetry(url, options, retries = 3) {
        for (let i = 0; i < retries; i++) {
            try {
                const response = await fetch(url, options);
                if (response.status !== 429) { 
                    return response;
                }
                console.log(`Rate limit exceeded. Retrying in ${2 ** i}s...`);
                await new Promise(resolve => setTimeout(resolve, 2 ** i * 1000));
            } catch (error) {
                console.error("Fetch error, retrying:", error);
                await new Promise(resolve => setTimeout(resolve, 2 ** i * 1000));
            }
        }
        throw new Error("Failed to fetch from API after multiple retries.");
    }

    // Main function to solve the handwritten math problem using Gemini
    async function solveHandwrittenMath() {
        if (API_KEY === "YOUR_API_KEY_HERE" || API_KEY === "") {
             showModal("कृपया कोड में अपनी Gemini API Key डालें। यह सुविधा इंटरनेट कनेक्शन और एक वैध Key के बिना काम नहीं करेगी।");
             return;
        }

        // 1. Disable button and show loading
        solveButton.disabled = true;
        solveButton.textContent = "हल किया जा रहा है... (Solving...)";
        
        // 2. Capture canvas image data and convert to base64
        const dataURL = canvas.toDataURL("image/png");
        const base64Data = dataURL.split(',')[1];
        
        // 3. Define the API call parameters
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${API_KEY}`;
        
        // System instruction to guide the AI's response format
        const systemPrompt = "Analyze the handwriting in this image. It contains a simple mathematical expression (e.g., 5+3, 12 * 4). Please state the full expression recognized and its final numerical answer. Respond only with the format: 'Expression: [recognized expression] | Answer: [final numerical result]'. If no clear math is visible, say 'No math detected'.";

        const payload = {
            contents: [
                {
                    role: "user",
                    parts: [
                        { text: "Analyze this image for a math problem." },
                        {
                            inlineData: {
                                mimeType: "image/png",
                                data: base64Data
                            }
                        }
                    ]
                }
            ],
            systemInstruction: {
                parts: [{ text: systemPrompt }]
            },
            generationConfig: {
                maxOutputTokens: 100 
            }
        };

        try {
            const response = await fetchWithRetry(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                throw new Error(`API returned status ${response.status}`);
            }

            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

            if (text) {
                let displayMessage;
                if (text.includes("No math detected")) {
                    displayMessage = "मुझे कोई साफ़ गणित की समस्या नहीं दिखी। कृपया बड़े और स्पष्ट अक्षर लिखने का प्रयास करें।";
                } else {
                    // Extract expression and answer using regex (simple parsing)
                    const matchExpression = text.match(/Expression:\s*([^|]+)/);
                    const matchAnswer = text.match(/Answer:\s*([^|]+)/);
                    
                    const recognizedExpression = matchExpression ? matchExpression[1].trim() : "अज्ञात (Unknown)";
                    const answer = matchAnswer ? matchAnswer[1].trim() : "नहीं मिला";

                    displayMessage = `मैंने पहचाना: ${recognizedExpression}। सही उत्तर है: <span class="font-extrabold text-blue-600">${answer}</span>`;
                }
                showModal(displayMessage);

            } else {
                showModal("क्षमा करें, AI छवि को प्रोसेस नहीं कर सका। कृपया पुनः प्रयास करें।");
            }

        } catch (error) {
            console.error("Error solving math:", error);
            showModal("गणित हल करते समय एक त्रुटि हुई। सुनिश्चित करें कि आपका इंटरनेट काम कर रहा है और Key वैध है।");
        } finally {
            // Re-enable button
            solveButton.disabled = false;
            solveButton.textContent = "Solve Handwritten Math";
        }
    }


    // ------------------------------------------------------------------
    // --- GRID LOGIC ---
    // ------------------------------------------------------------------

    function drawGrid() {
        if (!isGridVisible) return;

        // Save current context state before drawing grid
        ctx.save(); 
        
        ctx.strokeStyle = '#e5e7eb'; // Very light gray for grid lines
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]); // Dotted lines for subtlety

        // Draw vertical lines
        for (let x = GRID_SIZE; x < canvas.width; x += GRID_SIZE) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
        }

        // Draw horizontal lines
        for (let y = GRID_SIZE; y < canvas.height; y += GRID_SIZE) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }
        
        // Restore context state (important for drawing continuity)
        ctx.restore(); 
    }

    function toggleGrid() {
        isGridVisible = !isGridVisible;
        
        if (isGridVisible) {
            toggleGridButton.innerHTML = '<i class="fas fa-th-large mr-2"></i> Hide Grid';
            toggleGridButton.classList.replace('bg-purple-500', 'bg-pink-500');
        } else {
            toggleGridButton.innerHTML = '<i class="fas fa-th-large mr-2"></i> Show Grid';
            toggleGridButton.classList.replace('bg-pink-500', 'bg-purple-500');
        }
        
        // Always restore the state to redraw content and apply the new grid setting
        restoreState();
    }

    // ------------------------------------------------------------------
    // --- DRAWING LOGIC & UTILITIES ---
    // ------------------------------------------------------------------

    function showModal(message) {
        // Allow HTML content in modal message
        modalMessage.innerHTML = message;
        modal.classList.remove('hidden');
    }

    function hideModal() {
        modal.classList.add('hidden');
    }
    
    // --- History Management (Undo/Redo) ---
    
    function saveState() {
        // First, temporarily hide the grid if it's visible, so it doesn't get saved into the history image.
        const gridStateBeforeSave = isGridVisible;
        if (gridStateBeforeSave) {
            isGridVisible = false;
            // Draw content without grid to history (requires a full restore operation)
            restoreState(false); // Restore without calling drawGrid
        }

        if (historyIndex < history.length - 1) {
            history = history.slice(0, historyIndex + 1);
        }

        if (history.length >= MAX_HISTORY_STEPS) {
            history.shift(); 
            historyIndex--;
        }

        history.push(canvas.toDataURL());
        historyIndex++;

        // Restore grid state if it was visible
        if (gridStateBeforeSave) {
            isGridVisible = true;
            drawGrid(); // Redraw grid on top of the saved state
        }
        
        updateHistoryButtons();
    }

    // New signature: restoreState(shouldDrawGrid = true)
    function restoreState(shouldDrawGrid = true) {
        // 1. Synchronously clear the entire canvas state (removes visible grid and content immediately)
        ctx.clearRect(0, 0, canvas.width, canvas.height); 
        
        if (historyIndex >= 0 && historyIndex < history.length) {
            const img = new Image();
            img.onload = function() {
                // 2. Draw the actual content from history (content only)
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height); 
                // 3. Draw the grid on top (if visible), only if requested
                if (shouldDrawGrid) {
                    drawGrid(); 
                }
                updateHistoryButtons();
            };
            img.src = history[historyIndex];
        } else {
            // If history is empty, canvas is already cleared. Just draw grid if needed.
            if (shouldDrawGrid) {
                drawGrid(); 
            }
            updateHistoryButtons();
        }
    }

    function undo() {
        if (historyIndex > 0) {
            historyIndex--;
            restoreState();
        }
    }

    function redo() {
        if (historyIndex < history.length - 1) {
            historyIndex++;
            restoreState();
        }
    }

    function updateHistoryButtons() {
        undoButton.disabled = (historyIndex <= 0);
        redoButton.disabled = (historyIndex >= history.length - 1);
    }

    // --- Control Handlers ---

    function selectColor(color, element) {
        document.querySelectorAll('.color-swatch').forEach(swatch => swatch.classList.remove('selected'));
        element.classList.add('selected');
        colorPickerEl.value = color;
        updateStrokeColor(color);
        
        if (currentTool === 'eraser') {
            setTool('pen'); 
        }
    }
    
    function updateStrokeSize(size) {
        currentStrokeSize = parseInt(size);
        sizeValueEl.textContent = currentStrokeSize;
        ctx.lineWidth = currentStrokeSize;
    }
    
    function updateStrokeColor(color) {
        currentStrokeColor = color;
        ctx.strokeStyle = currentStrokeColor;
        document.querySelectorAll('.color-swatch').forEach(swatch => swatch.classList.remove('selected'));
        const customSwatch = Array.from(document.querySelectorAll('.color-swatch')).find(s => s.dataset.color === color);
        if (customSwatch) {
             customSwatch.classList.add('selected');
        }
    }

    function setTool(toolName) {
        currentTool = toolName;
        const settings = TOOL_SETTINGS[toolName];

        document.querySelectorAll('.tool-icon').forEach(icon => {
            icon.classList.toggle('selected', icon.getAttribute('data-tool') === toolName);
        });

        if (toolName === 'eraser') {
            ctx.strokeStyle = CANVAS_BACKGROUND;
            colorControlEl.style.opacity = '0.5';
            colorControlEl.style.pointerEvents = 'none';
        } else {
            ctx.strokeStyle = currentStrokeColor;
            colorControlEl.style.opacity = '1';
            colorControlEl.style.pointerEvents = 'auto';
        }
        
        sizeSliderEl.value = settings.size;
        updateStrokeSize(settings.size); 
        ctx.lineCap = settings.lineCap;
        ctx.lineJoin = settings.lineJoin;
    }

    function clearCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        history = [];
        historyIndex = -1;
        drawGrid(); // Redraw grid if visible
        saveState(); 
        showModal("Canvas cleared! Time for a new masterpiece or math problem.");
    }

    function saveDrawing() {
        // Temporarily hide grid before saving
        const gridStateBeforeSave = isGridVisible;
        if (gridStateBeforeSave) {
            isGridVisible = false;
            restoreState(false); // Restore content without drawing grid
        }

        const imageURL = canvas.toDataURL("image/png");
        const a = document.createElement('a');
        a.href = imageURL;
        a.download = `Kids_Studio_Artwork_${new Date().toISOString()}.png`;
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        // Restore grid visibility after saving
        if (gridStateBeforeSave) {
            isGridVisible = true;
            drawGrid();
        }

        showModal("Artwork saved successfully!");
    }

    // --- Drawing Interaction ---

    function draw(e) {
        if (!isDrawing) return;
        
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;

        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else { 
            clientX = e.clientX;
            clientY = e.clientY;
        }

        const currentX = clientX - rect.left;
        const currentY = clientY - rect.top;

        // FIX CONFIRMED: No restoreState() call here.
        // Drawing happens normally, even with the grid visible.

        ctx.strokeStyle = (currentTool === 'eraser') ? CANVAS_BACKGROUND : currentStrokeColor;
        ctx.lineWidth = currentStrokeSize;
        ctx.setLineDash([]); // Ensure drawing strokes are solid

        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(currentX, currentY);
        ctx.stroke();

        [lastX, lastY] = [currentX, currentY];
    }

    function setPosition(e) {
        isDrawing = true;
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;

        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        
        [lastX, lastY] = [clientX - rect.left, clientY - rect.top];
        e.preventDefault(); 
    }

    function stopDrawing() {
        if (isDrawing) {
            isDrawing = false;
            saveState(); 
        }
        ctx.beginPath();
    }

    // --- Resizing ---
    
    function resizeCanvas(targetSize) {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(canvas, 0, 0);

        // Constrain size by screen width
        const newSize = Math.min(targetSize, document.body.clientWidth - 40);

        canvas.width = newSize;
        canvas.height = newSize;
        
        ctx.drawImage(tempCanvas, 0, 0, newSize, newSize);
        drawGrid(); // Redraw grid after resize and content restoration

        canvasSizeDisplayEl.textContent = `Canvas Size: ${targetSize} x ${targetSize}`;

        setTool(currentTool); 
    }
    
    function changeCanvasSize(delta) {
        let newIndex = currentCanvasSizeIndex + delta;

        newIndex = Math.max(0, Math.min(CANVAS_SIZES.length - 1, newIndex));

        if (newIndex !== currentCanvasSizeIndex) {
            currentCanvasSizeIndex = newIndex;
            const targetSize = CANVAS_SIZES[currentCanvasSizeIndex].size;
            resizeCanvas(targetSize);
            showModal(`Drawing area changed to ${targetSize}x${targetSize} pixels!`);
        } else {
             if (delta < 0) {
                 showModal(`Cannot decrease further. Min size is ${CANVAS_SIZES[0].size}x${CANVAS_SIZES[0].size}.`);
             } else {
                 showModal(`Cannot increase further. Max size is ${CANVAS_SIZES[CANVAS_SIZES.length - 1].size}x${CANVAS_SIZES[CANVAS_SIZES.length - 1].size}.`);
             }
        }
    }

    function handleWindowResize() {
        const targetSize = CANVAS_SIZES[currentCanvasSizeIndex].size;
        resizeCanvas(targetSize);
    }

    function initializeCanvas() {
        setTool('pen'); 
        // Start at Large (index 2: 800x800)
        currentCanvasSizeIndex = 2; 
        resizeCanvas(CANVAS_SIZES[currentCanvasSizeIndex].size); 
        saveState(); // Save the initial empty state
    }

    // --- Event Listeners ---
    canvas.addEventListener('mousedown', setPosition);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);

    canvas.addEventListener('touchstart', setPosition);
    canvas.addEventListener('touchmove', draw);
    canvas.addEventListener('touchend', stopDrawing);
    
    window.addEventListener('resize', handleWindowResize);
    window.onload = initializeCanvas;
</script>

</body>
</html>
